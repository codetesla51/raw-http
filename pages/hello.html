<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>About This Server | Uthman's Web Server</title>
  <link rel="stylesheet" href="/styles.css">
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
</head>

<body>
  <div class="container">
    <h1>
      <i data-lucide="server" class="header-icon"></i>
      HTTP Server from Scratch
    </h1>
    
    <p>This lightweight HTTP server was built from raw TCP sockets in Go to understand HTTP protocol internals and
      network programming fundamentals. No frameworks, no shortcuts - just pure socket programming.</p>
    
    <h3>
      <i data-lucide="zap" class="section-icon"></i>
      Core Features
    </h3>
    <div class="feature-list">
      <ul>
        <li>
          <i data-lucide="network"></i>
          <strong>Raw TCP handling</strong> - Parses HTTP requests directly from socket connections
        </li>
        <li>
          <i data-lucide="git-branch"></i>
          <strong>Custom routing</strong> - Simple router with method and path matching
        </li>
        <li>
          <i data-lucide="file-text"></i>
          <strong>Static file serving</strong> - Serves files with proper MIME type detection
        </li>
        <li>
          <i data-lucide="layout-template"></i>
          <strong>Template rendering</strong> - Supports Go's html/template for dynamic content
        </li>
        <li>
          <i data-lucide="link"></i>
          <strong>Connection management</strong> - Keep-alive support with proper connection reuse
        </li>
        <li>
          <i data-lucide="shield"></i>
          <strong>Security basics</strong> - Path traversal protection and request limits
        </li>
        <li>
          <i data-lucide="file-input"></i>
          <strong>Form & JSON parsing</strong> - Handles both URL-encoded forms and JSON bodies
        </li>
      </ul>
    </div>
    
    <h3>
      <i data-lucide="trending-up" class="section-icon"></i>
      Performance Journey
    </h3>
    <div class="info-card">
      <h4>
        <i data-lucide="bug"></i>
        The Optimization Story
      </h4>
      <p><strong>250 RPS → 282 RPS:</strong> Fixed initial bug affecting request processing</p>
      <p><strong>282 RPS → 1710 RPS:</strong> Removed connection limit loop to enable proper keep-alive</p>
      <p><strong>Result:</strong> 6-7x performance increase from initial buggy version!</p>
    </div>
    
    <div class="feature-list">
      <h4>Current Performance Stats</h4>
      <ul>
        <li>
          <i data-lucide="gauge"></i>
          <strong>Peak throughput:</strong> ~1710 RPS with keep-alive enabled
        </li>
        <li>
          <i data-lucide="clock"></i>
          <strong>Response time:</strong> 0.585ms mean, most requests complete in 12-20ms
        </li>
        <li>
          <i data-lucide="target"></i>
          <strong>Reliability:</strong> 0% failure rate across all test scenarios
        </li>
        <li>
          <i data-lucide="activity"></i>
          <strong>Connection reuse:</strong> 100% efficiency with keep-alive
        </li>
      </ul>
    </div>
    
    <h3>
      <i data-lucide="lightbulb" class="section-icon"></i>
      What I Learned Building This
    </h3>
    <div class="feature-list">
      <ul>
        <li>
          <i data-lucide="layers"></i>
          How HTTP requests are structured and parsed at the protocol level
        </li>
        <li>
          <i data-lucide="refresh-cw"></i>
          TCP connection lifecycle and keep-alive mechanics
        </li>
        <li>
          <i data-lucide="shield-check"></i>
          Security considerations (DoS protection, path traversal attacks)
        </li>
        <li>
          <i data-lucide="cpu"></i>
          Go's networking primitives and goroutine-per-connection model
        </li>
        <li>
          <i data-lucide="template"></i>
          Template rendering and form data handling from scratch
        </li>
        <li>
          <i data-lucide="trending-up"></i>
          The critical importance of proper connection reuse for performance
        </li>
      </ul>
    </div>
    
    <h3>
      <i data-lucide="folder" class="section-icon"></i>
      Project Structure
    </h3>
    <div class="info-card">
      <pre><code>├── server/
│   ├── server.go          # Core HTTP server logic
│   └── server_test.go     # Test suite
├── pages/                 # Static files and templates
│   ├── index.html
│   ├── login.html
│   ├── welcome.html
│   └── styles.css
└── main.go               # Example web application</code></pre>
    </div>
    
    <h3>
      <i data-lucide="alert-triangle" class="section-icon"></i>
      Limitations & Design Choices
    </h3>
    <div class="feature-list">
      <p><strong>This is a learning project, not production software:</strong></p>
      <ul>
        <li>
          <i data-lucide="x-circle"></i>
          No HTTPS/TLS support (security not the focus)
        </li>
        <li>
          <i data-lucide="alert-circle"></i>
          Basic error handling (prioritized learning over robustness)
        </li>
        <li>
          <i data-lucide="route"></i>
          Simple routing (no path parameters or regex matching)
        </li>
        <li>
          <i data-lucide="layers"></i>
          No middleware system (kept architecture simple)
        </li>
        <li>
          <i data-lucide="server"></i>
          Limited HTTP method support (focused on GET/POST)
        </li>
      </ul>
    </div>
    
    <h3>
      <i data-lucide="target" class="section-icon"></i>
      Why Build This?
    </h3>
    <div class="info-card">
      <p>Most web development happens at the framework level (Express, Flask, etc.). Building from TCP sockets up helps
        understand what's actually happening under the hood - HTTP parsing, connection management, and the networking
        fundamentals that frameworks abstract away.</p>
      
      <p><strong>Key Insight:</strong> The performance optimization journey from ~280 RPS to ~1700 RPS by fixing
        connection reuse demonstrates how low-level implementation details can have dramatic performance impacts.</p>
    </div>
    
    <div class="nav-links">
      <a href="/">
        <i data-lucide="home"></i>
        Back to Home
      </a>
      <a href="https://github.com/codetesla51/raw-http">
        <i data-lucide="github"></i>
        View Source Code
      </a>
      <a href="/login.html">
        <i data-lucide="play"></i>
        Try the Demo
      </a>
    </div>
    
    <div class="info-card">
      <h4>
        <i data-lucide="code"></i>
        Built with Go 1.21+
      </h4>
      <p>Created by <strong>Uthman</strong> as a deep dive into HTTP server fundamentals and Go's networking
        capabilities. Every line written from scratch to understand the magic behind web servers.</p>
    </div>
  </div>
  
  <script>
    lucide.createIcons();
  </script>
</body>

</html>